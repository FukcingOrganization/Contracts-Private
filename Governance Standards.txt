
// Get these to have contract governance

*********************************************************
enum Status{
    NotStarted, // Index: 0
    OnGoing,    // Index: 1
    Approved,   // Index: 2
    Denied      // Index: 3
}

struct Proposal {
    Status status;
    uint256 updateCode; // Update code helps to differentiate different variables with same data type. Starts from 1.
    bool isExecuted;    // If executed, the data and proposal no longer can be used.
    
    uint256 index;      // The index of target array. See arrays below.
    uint256 newUint;
    address newAddress;
    bytes32 newBytes32;
    bool newBool;
}


/**
 * contracts' Indexes with corresponding meaning
 *  
 * Index 0: Boss Contract             
 * Index 1: Clan Contract              
 * Index 2: ClanLicence Contract        
 * Index 3: Community Contract         
 * Index 4: DAO Contract               
 * Index 5: Executor Contract            
 * Index 6: Items Contract            
 * Index 7: Lord Contract               
 * Index 8: Rent Contract               
 * Index 9: Seance Contract             
 * Index 10: Staking Contract           
 * Index 11: Token Contract          
 * Index 12: Developer Contract/address  
 */
address[13] public contracts; 

mapping(uint256 => Proposal) public proposals;          // Proposal ID => Proposal

*********************************************************

- Get the ID of new proposal
- Write change data into the proposals[propID] to use.
- Keep updateCode

- Check if the proposal has been approved
- If approved, apply changes to the state variables and set proposals[propID].isExecuted = true 

Example Functions:

Array index change:
    function proposeContractAddressUpdate(uint256 _contractIndex, address _newAddress) public {
        require(_msgSender() == contracts[5], "Only executors can call this fukcing function!");
        require(_newAddress != address(0), "New address can not be the null address!");

        string memory proposalDescription = string(abi.encodePacked(
            "Updating contract address of index ", Strings.toHexString(_contractIndex), " to ", 
            Strings.toHexString(_newAddress), " from ", Strings.toHexString(contracts[_contractIndex]), "."
        )); 

        // Create a new proposal - Call DAO contract (contracts[4]) - proposal type : 2 - Highly Important
        (bool txSuccess, bytes memory returnData) = contracts[4].call(
            abi.encodeWithSignature("newProposal(string,uint256)", proposalDescription, proposalTypes[2])
        );
        require(txSuccess, "Transaction failed to make new proposal!");

        // Save the ID to create proposal in here
        (uint256 propID) = abi.decode(returnData, (uint256));

        // Save data to the proposal
        proposals[propID].updateCode = 1;
        proposals[propID].index = _contractIndex;
        proposals[propID].newAddress = _newAddress;
    }

    function executeContractAddressUpdateProposal(uint256 _proposalID) public {
        Proposal storage proposal = proposals[_proposalID];

        require(proposal.updateCode == 1, "Wrong proposal ID");
        require(proposal.isExecuted == false, "Wrong proposal ID");
        
        // Get the result from DAO
        (bool txSuccess, bytes memory returnData) = contracts[4].call(
            abi.encodeWithSignature("proposalResult(uint256)", _proposalID)
        );
        require(txSuccess, "Transaction failed to retrieve DAO result!");
        (uint256 statusNum) = abi.decode(returnData, (uint256));

        // Save it here
        proposal.status = Status(statusNum);

        // Wait for the current one to finalize
        require(uint256(proposal.status) > 1, "The proposal still going on or not even started!");

        // if approved, apply the update the state
        if (proposal.status == Status.Approved)
            contracts[proposal.index] = proposal.newAddress;

        proposal.isExecuted = true;
    }

Normal variable change:
    function proposeToIncreaseMaxSupply(new value) public {
        require(_msgSender() == contracts[5], "Only executors can call this fukcing function!");

        string memory proposalDescription = string(abi.encodePacked(
            "DESCRIPTON: ", Strings.toHexString(new value), 
            ". The current supply is ", Strings.toHexString(current value), "."
        )); 

        // Create a new proposal - Call DAO contract (contracts[4])
        (bool txSuccess, bytes memory returnData) = contracts[4].call(
             abi.encodeWithSignature("newProposal(string,uint256)", proposalDescription, proposal type here)
        );
        require(txSuccess, "Transaction failed to make new proposal!");

        // Get the ID
        (uint256 propID) = abi.decode(returnData, (uint256));

        // Save data to the local proposal
        proposals[propID].updateCode = upcode here ;
        proposals[propID].change variable = new value;
    }

    function executeIncreaseMaxSupplyProposal(uint256 _proposalID) public {
        Proposal storage proposal = proposals[_proposalID];

        require(proposal.updateCode == upcode here, "Wrong proposal ID");
        require(proposal.isExecuted == false, "Wrong proposal ID");

        // Get the proposal result from DAO
        (bool txSuccess, bytes memory returnData) = contracts[4].call(
            abi.encodeWithSignature("proposalResult(uint256)", _proposalID)
        );
        require(txSuccess, "Transaction failed to retrieve DAO result!");
        (uint256 statusNum) = abi.decode(returnData, (uint256));

        // Save the result here
        proposal.status = Status(statusNum);

        // Check if it is finalized or not
        require(uint256(proposal.status) > 1, "The proposal still going on or not even started!");

        // if the proposal is approved, apply the update the state
        if (proposal.status == Status.Approved)
            state variable = proposal.change variable;

        proposal.isExecuted = true;
    }



*********************************************************


Define an update code for each variable like; (update codes starts from 1 !!!)
/**
  * Updates by DAO
  * contracts -> Update Code: 1
  * mintPerSecond -> Update Code: 2
  * maxSupply ->Update Code: 3
  * proposalTypes -> Up. Code: 4
  * 
  */